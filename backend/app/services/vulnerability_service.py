"""
Vulnerability management service
"""
from sqlalchemy.orm import Session, joinedload
from typing import List, Optional

from app.models.vulnerability import Vulnerability
from app.models.feedback import Feedback
from app.models.scan import Scan
from app.schemas.vulnerability import VulnerabilityUpdate, FeedbackCreate
from app.services.cve_service import CVEService
from app.services.llm_service import LLMService
from app.services.command_templates import CommandTemplates


class VulnerabilityService:
    def __init__(self, db: Session):
        self.db = db
        self.cve_service = CVEService()
        self.llm_service = LLMService()
    
    def get_vulnerabilities(
        self,
        user_id: int,
        scan_id: Optional[int] = None,
        severity: Optional[str] = None,
        status: Optional[str] = None,
        skip: int = 0,
        limit: int = 100
    ) -> List[Vulnerability]:
        """Get vulnerabilities with filters"""
        
        query = (
            self.db.query(Vulnerability)
            .join(Scan)
            .filter(Scan.user_id == user_id)
        )
        
        if scan_id:
            query = query.filter(Vulnerability.scan_id == scan_id)
        
        if severity:
            query = query.filter(Vulnerability.severity == severity)
        
        if status:
            query = query.filter(Vulnerability.status == status)
        
        return (
            query
            .options(joinedload(Vulnerability.scan))
            .order_by(Vulnerability.created_at.desc())
            .offset(skip)
            .limit(limit)
            .all()
        )
    
    def get_vulnerability(self, vuln_id: int) -> Optional[Vulnerability]:
        """Get vulnerability by ID"""
        return (
            self.db.query(Vulnerability)
            .options(joinedload(Vulnerability.scan))
            .filter(Vulnerability.id == vuln_id)
            .first()
        )
    
    def update_vulnerability(self, vuln_id: int, update_data: VulnerabilityUpdate) -> Vulnerability:
        """Update vulnerability"""
        vulnerability = self.get_vulnerability(vuln_id)
        
        if update_data.status:
            vulnerability.status = update_data.status
        
        self.db.commit()
        self.db.refresh(vulnerability)
        return vulnerability
    
    def add_feedback(self, vuln_id: int, user_id: int, feedback_data: FeedbackCreate) -> Feedback:
        """Add feedback for vulnerability"""
        feedback = Feedback(
            vulnerability_id=vuln_id,
            user_id=user_id,
            rating=feedback_data.rating,
            comment=feedback_data.comment,
            feedback_type=feedback_data.feedback_type
        )
        
        self.db.add(feedback)
        self.db.commit()
        self.db.refresh(feedback)
        return feedback
    
    def delete_vulnerability(self, vuln_id: int) -> bool:
        """Delete vulnerability"""
        vulnerability = self.get_vulnerability(vuln_id)
        if vulnerability:
            self.db.delete(vulnerability)
            self.db.commit()
            return True
        return False
    
    async def refresh_cve_data(self, vuln_id: int) -> Optional[Vulnerability]:
        """Refresh CVE data for a vulnerability"""
        vulnerability = self.get_vulnerability(vuln_id)
        if not vulnerability:
            return None
        
        try:
            # Lookup CVE information
            cve_info = await self.cve_service.lookup_cve(
                vulnerability.service_name,
                vulnerability.service_version or "",
                ""
            )
            
            if cve_info:
                vulnerability.cve_id = cve_info.get("cve_id")
                vulnerability.cvss_score = cve_info.get("cvss_score")
                if cve_info.get("severity"):
                    vulnerability.severity = cve_info["severity"]
                
                # Also get enhanced description from CVE if available
                if cve_info.get("description") and not vulnerability.description:
                    vulnerability.description = cve_info["description"]
            
            # Get LLM analysis for recommendations
            if vulnerability.service_name:
                analysis = await self.llm_service.analyze_vulnerability(
                    service_name=vulnerability.service_name,
                    version=vulnerability.service_version or "",
                    port=vulnerability.port or 0,
                    vulnerability_description=vulnerability.description or "",
                    cve_id=vulnerability.cve_id
                )
                
                if analysis:
                    if analysis.get("recommendation"):
                        vulnerability.recommendation = analysis["recommendation"]
                    if analysis.get("remediation_commands"):
                        vulnerability.remediation_commands = analysis["remediation_commands"]
                    else:
                        # Fallback to template commands if LLM didn't generate any
                        template_commands = CommandTemplates.get_commands_for_service(
                            vulnerability.service_name, 
                            vulnerability.service_version or ""
                        )
                        if template_commands:
                            vulnerability.remediation_commands = template_commands
                else:
                    # No LLM analysis available, use template commands
                    template_commands = CommandTemplates.get_commands_for_service(
                        vulnerability.service_name, 
                        vulnerability.service_version or ""
                    )
                    if template_commands:
                        vulnerability.remediation_commands = template_commands
            
            self.db.commit()
            self.db.refresh(vulnerability)
            return vulnerability
            
        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f"Error refreshing CVE data: {e}")
            return vulnerability
    
    def user_has_access(self, vulnerability: Vulnerability, user_id: int, user_role: str) -> bool:
        """Check if user has access to vulnerability"""
        if user_role == "admin":
            return True
        
        return vulnerability.scan.user_id == user_id
    
    def get_vulnerabilities_grouped_by_scan(self, user_id: int) -> List[dict]:
        """Get vulnerabilities grouped by scan"""
        from collections import defaultdict
        
        # Get all vulnerabilities for user with scan info
        vulnerabilities = (
            self.db.query(Vulnerability)
            .join(Scan)
            .filter(Scan.user_id == user_id)
            .options(joinedload(Vulnerability.scan))
            .order_by(Scan.upload_time.desc(), Vulnerability.created_at.desc())
            .all()
        )
        
        # Group by scan
        scan_groups = defaultdict(list)
        scan_info = {}
        
        for vuln in vulnerabilities:
            scan_id = vuln.scan_id
            scan_groups[scan_id].append(vuln)
            
            # Store scan info if not already stored
            if scan_id not in scan_info:
                scan_info[scan_id] = {
                    'id': vuln.scan.id,
                    'filename': vuln.scan.filename,
                    'original_filename': vuln.scan.original_filename,
                    'upload_time': vuln.scan.upload_time,
                    'status': vuln.scan.status
                }
        
        # Convert to list format with scan info
        result = []
        for scan_id, vulns in scan_groups.items():
            result.append({
                'scan': scan_info[scan_id],
                'vulnerabilities': vulns,
                'vulnerability_count': len(vulns),
                'severity_summary': self._get_severity_summary(vulns)
            })
        
        # Sort by upload_time (newest first)
        result.sort(key=lambda x: x['scan']['upload_time'], reverse=True)
        return result
    
    def _get_severity_summary(self, vulnerabilities: List[Vulnerability]) -> dict:
        """Get severity count summary for vulnerabilities"""
        summary = {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0, 'Unknown': 0}
        
        for vuln in vulnerabilities:
            severity = vuln.severity or 'Unknown'
            if severity in summary:
                summary[severity] += 1
            else:
                summary['Unknown'] += 1
                
        return summary
